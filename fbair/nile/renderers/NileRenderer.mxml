<!--
  Copyright Facebook Inc.

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 -->
<!-- Chief Renderer for every entry in the Stream.
     There's exactly one of these for each entry.
     It contains inside it a CommentsRenderer and LikesRenderer
     And alternatively one "ContentRenderer" if it is not a Status Update.
     We also manage the actions of Liking and Commenting here -->
<util:AnimatedCanvas xmlns:mx="http://www.adobe.com/2006/mxml"
                     xmlns:gui="fbair.gui.*"
                     xmlns:renderer="fbair.nile.renderers.*"
                     xmlns:util="fbair.util.display.*"
                     implements="fbair.gc.Recyclable"
                     includeInLayout="{false}"
                     minWidth="369"
                     width="100%"
                     animate="false"
                     animateIn="{data.filter_key == NileContainer.CurrentFilter}"
                     animateOut="{data.filter_key == NileContainer.CurrentFilter}"
                     animateOnce="true"
                     creationComplete="creationComplete(event)" >

  <mx:HBox styleName="nileRenderer"
           width="100%" >

    <!-- Main big image of Profile pic of Actor of this Stream entry -->
    <gui:RoundedProfileImage id="profilePic"
                             profileID="{data.actor_id}"
                             size="{StylePrefs.sizeStyle
                                    == StylePrefs.SIZE_LARGE ?
                                    PicSizeLarge : PicSizeSmall}" />

    <mx:VBox width="100%"
             styleName="storyContent" >

      <mx:HBox width="100%"
               horizontalGap="4" >

        <!-- Main text of actor's name and their status message -->
        <mx:Text styleName="actorAndMessage"
                 htmlText="{data.actorAndMessage}"
                 width="100%" />

        <!-- No deleting until bug fixed in stream.remove -->
        <mx:Button id="storyDeleteButton"
                   styleName="storyDeleteButton"
                   buttonMode="true"
                   includeInLayout="{MathUtil.and(
                        data.actor_id == FBConnect.session.uid,
                        data.app_id == ApplicationBase.AppID
                      )}"
                   visible="{storyDeleteButton.includeInLayout}"
                   click="deleteStory(event)" />
      </mx:HBox>

      <!-- We place the stream entry's content in this canvas if it has any
           ex:  Photo, Album, Link, Video, etc -->
      <util:AnimatedCanvas width="100%"
                           id="contentBox"
                           styleName="contentBox"
                           animateIn="false"
                           animate="{data.filter_key == NileContainer.CurrentFilter}" >
      </util:AnimatedCanvas>

      <!-- This is the row of action links we can take for this stream entry.
           The two defaults are Like and Comment... -->
      <renderer:ActionRow id="actionRow"
                          width="100%"
                          likeClick="likeClicked(event)"
                          commentClick="commentClicked(event)"
                          data="{data}" />

      <renderer:UFI id="ufi"
                    width="100%"
                    data="{data}" />
    </mx:VBox>

  </mx:HBox>

  <mx:Script><![CDATA[
    import fb.FBAPI;
    import fb.FBConnect;
    import fb.FBEvent;
    import fb.util.MathUtil;
    import fb.util.Output;

    import fbair.gc.Depot;
    import fbair.gui.StylePrefs;
    import fbair.nile.Nile;
    import fbair.nile.NileContainer;
    import fbair.util.ProfileCache;
    import fbair.util.StringUtil;

    import flash.events.Event;
    import flash.events.MouseEvent;

    import mx.collections.ArrayCollection;
    import mx.core.Application;
    import mx.core.Container;
    import mx.utils.ObjectProxy;

    public static const STORY_REMOVED:String = "storyRemoved";

    private static const PicSizeLarge:int = 42;
    private static const PicSizeSmall:int = 36;

    // Our attachment renderer, if we make one
    private var content:AttachmentRenderer;

    private function creationComplete(evt:Event):void {
      includeInLayout = visible;

      // debug trace
      profilePic.addEventListener(MouseEvent.CLICK, clickedProfilePic, true);
    }

    override protected function createChildren():void {
      super.createChildren();

      // If we created content in our data setter then add it now
      if (content) contentBox.addChild(content);
    }

    // Save the earth, kids!
    public function recycle():void {
      if (content) {
        if (contentBox.contains(content))
          contentBox.removeChild(content);
        Depot.put(content);
        content = null;
      }

      // Clear out the ufi
      ufi.destroy();
      
      // No more data!
      super.data = null;
    }

    private function clickedProfilePic(event:MouseEvent):void {
      if (!event.shiftKey) return;
      Output.alert(data);
      event.stopImmediatePropagation();
    }

    // Called when we want to like or unlike this stream entry
    private function likeClicked(event:Event):void {
      if (!data.likes.can_like) return;

      // Don't allow the link to be re-clicked during the period
      //   when we're posting to the server...
      actionRow.likeLink.enabled = false;

      // Build our args and method depending on whether
      //   we're liking or unliking here
      var args:Object = {post_id:data.post_id};
      var method:String = (data.likes.user_likes ?
                          "stream.removeLike" : "stream.addLike");

      // Call the server to like/unlike this stream entry
      FBAPI.callMethod(method, args)
        .addEventListener(FBEvent.SUCCESS, function(event:FBEvent):void {
            // Update our data.likes object to reflect these changes
            data.likes.immune = true; // So immediate update doesn't flip back
            data.likes.user_likes = !data.likes.user_likes;
            data.likes.count += data.likes.user_likes ? 1 : -1;

            // Update our likeLink text and re-enable for next time
            actionRow.data = data;
            actionRow.likeLink.enabled = true;

            // Update our likesRenderer now that we've changed it's data
            ufi.likesRenderer.update();
        });
    }

    // Called when we want to begin commenting or end commenting.
    // This just displays/hides the comment text area.
    private function commentClicked(event:Event):void {
      data.commentBoxActive = true;
      ufi.ufiMode = UFI.UFI_DETAIL;
      Application.application.focusManager.setFocus(
        ufi.commentBox.commentInput);
    }

    // Raw stream.get json decoded entry
    // We'll pass along pieces to our CommentsRenderer, LikesRenderer
    //    and perhaps a "ContentRenderer"
    override public function set data(new_data:Object):void {
      Output.assert(new_data != null,
        "Setting null data on NileRenderer?: " + this);

      // We don't want to rebuild this string every time
      if (data && data.actorAndMessage)
        new_data.actorAndMessage = data.actorAndMessage;

      // Set immunity on likes
      if (new_data.likes) {
        if (data && data.likes && data.likes.immune) {
          if (new_data.likes.user_likes != data.likes.user_likes) {
            new_data.likes.user_likes = data.likes.user_likes;
            if (new_data.likes.user_likes) new_data.likes.count++;
            else new_data.likes.count--;
          }
        }
      }

      // Ok NOW that everything is proxied, we set our data
      super.data = new ObjectProxy(new_data);
      if (!data) return;

      // Get name of our actor, to build message text, if not already built
      // If this entry has a target, let's get that profile data too
      if (!data.actorAndMessage) {
        if (data.target_id) {
          ProfileCache.getProfile(data.target_id).addEventListener(
            ProfileCache.PROFILE_FETCHED, profileFetched);
        }
        ProfileCache.getProfile(data.actor_id).addEventListener(
          ProfileCache.PROFILE_FETCHED, profileFetched);
      }

      // Determine whether we have special content
      //   that requires a "ContentRenderer".
      // If we don't already have a ContentRenderer...
      if (!content && data.attachment.media) {
        // Turn attachment into collection for binding
        if ((data.attachment.media is Array)) {
          for (var i:int = 0; i < data.attachment.media.length; i++) {
            data.attachment.media[i] = new
              ObjectProxy(data.attachment.media[i]);
          }
          data.attachment.media = new ArrayCollection(data.attachment.media);
        } else {
          data.attachment.media = new ArrayCollection();
        }

        // Create correct type of content
        content = Depot.get(AttachmentRenderer);
        content.percentWidth = 100;
        content.data = data.attachment;
        
        if (contentBox) contentBox.addChild(content);
      }
    }

    // Called when we've fetched profile data about actor.
    private function profileFetched(event:FBEvent):void {
      if (!data) return;

      // Make sure the profile cach has what we need
      if (!ProfileCache.hasProfile(data.actor_id)) return;
      if (data.target_id && !ProfileCache.hasProfile(data.target_id)) return;

      // Get our actor data
      var actorData:Object = ProfileCache.cache[data.actor_id];

      // Build our body that contains actor/target/message
      var body:String = StringUtil.linkify(actorData.name, actorData.url);
      if (ProfileCache.hasProfile(data.target_id))
        body += StringUtil.colorize(' ► ', 'aaaaaa') +
                StringUtil.linkify(ProfileCache.cache[data.target_id].name,
                                   ProfileCache.cache[data.target_id].url);
      if (data.message)
        body += '  ' + StringUtil.htmlize(data.message);
      data.actorAndMessage = body;
    }

    // Called to delete ourself!
    private function deleteStory(event:MouseEvent):void {
      // We don't want the user clicking it twice
      storyDeleteButton.enabled = false;

      // Call the server and delete our comment
      FBAPI.callMethod("stream.remove", {post_id:data.post_id})
        .addEventListener(FBEvent.SUCCESS, function(event:FBEvent):void {
          dispatchEvent(new Event(STORY_REMOVED, true));
        });
    }
  ]]></mx:Script>
</util:AnimatedCanvas>
